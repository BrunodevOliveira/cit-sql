import * as vscode from 'vscode';
import axios from 'axios';
import * as path from 'path';

export function activate(context: vscode.ExtensionContext) {
    let disposable = vscode.commands.registerCommand('extension.executeSqlQuery', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active text editor');
            return;
        }

        const selection = editor.selection;
        const text = editor.document.getText(selection).replace(/\r\n|\r|\n/g, ' ');

        if (!text) {
            vscode.window.showErrorMessage('No text selected');
            return;
        }        

        const { endpoint, token, query } = extrairEndpointTokenQuery(text);

        if (endpoint) {
            context.globalState.update('sqlQueryExecutor.endpoint', endpoint);
        }
        if (token) {
            context.globalState.update('sqlQueryExecutor.token', token);
        }

        const storedEndpoint = context.globalState.get('sqlQueryExecutor.endpoint') as string;
        const storedToken = context.globalState.get('sqlQueryExecutor.token') as string;

        const finalEndpoint = endpoint || storedEndpoint;
        const finalToken = token || storedToken;

        if (!finalEndpoint || !finalToken) {
            vscode.window.showErrorMessage('Endpoint or token not provided and not found in storage');
            return;
        }

        try {
            
            const response = await axios.post(finalEndpoint!, { sql: query }, { headers: { 'Authorization': `Bearer ${finalToken}` } });
            const data = response.data.retorno;

            if (!Array.isArray(data)) {
                throw new Error('Invalid response format');
            }

            // Criar um arquivo temporário para o Markdown
            const tempDir = vscode.workspace.workspaceFolders?.[0].uri.fsPath || __dirname;
            const tempFile = path.join(tempDir, 'sql_query_results.md');
            const uri = vscode.Uri.file(tempFile);

            // Escrever o conteúdo Markdown no arquivo
            await vscode.workspace.fs.writeFile(uri, Buffer.from(criarTabela(data, finalEndpoint)));

            // Abrir a visualização do Markdown Preview Enhanced
            await vscode.commands.executeCommand('markdown-preview-enhanced.openPreview', uri);
        } catch (error) {
            vscode.window.showErrorMessage(`Error executing query: ${error}`);
        }
    });

    context.subscriptions.push(disposable);
}

function extrairEndpointTokenQuery(text: string): { endpoint?: string; token?: string; query: string } {
    const endpointMatch = text.match(/--endpoint:\s*(https?:\/\/[^\s]+)/);
    const tokenMatch = text.match(/--token:\s*([^\s]+)/);

    const endpoint = endpointMatch ? endpointMatch[1] : undefined;
    const token = tokenMatch ? tokenMatch[1] : undefined;
    
    let query = text;
    if (endpointMatch) {
        query = query.replace(endpointMatch[0], '');
    }
    if (tokenMatch) {
        query = query.replace(tokenMatch[0], '');
    }
    query = query.trim();

    return { endpoint, token, query };
}

function criarTabela(data: any[], endpoint: string): string {
    if (data.length === 0) return 'Sem registros';

    const headers = Object.keys(data[0]);
    let table = `### API ${endpoint} \n\n`;
    table += '| ' + headers.join(' | ') + ' |\n';
    table += '| ' + headers.map(() => ':---:').join(' | ') + ' |\n';

    data.forEach(row => {
        table += '| ' + headers.map(header => row[header] || '').join(' | ') + ' |\n';
    });

    // Adicionar informações extras
    table += '\n\n*Query executada em: ' + new Date().toLocaleString() + '*\n';
    // table += '\n---\n';
    // table += 'Generated by SQL Query Executor Extension';

    return table;
}

export function deactivate() {}